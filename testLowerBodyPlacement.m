%load the robot into the environment
orEnvLoadScene('openHubo/openFloor.env.xml',1);

%Define mapping of joint names to indices
%TODO: Make this automatic (works in python with the GetJoints function)
%NOTE: This is vulnerable to any changes in the openHubo model!
jointPairs.names={'WST';'LHY';'LHR';'LHP';'LKP';'LAP';'LAR';
                        'RHY';'RHR';'RHP';'RKP';'RAP';'RAR'}
jointPairs.indexVector=[5 25 26 27 28 29 30 32 33 34 35 36 37];
jointPairs.signVector=[1 -1 -1 -1 1 -1 -1 -1 1 -1 1 -1 -1];

robotid = orEnvGetBody('jaemiHubo');

%set printing and display options
orEnvSetOptions('debug 2')
orEnvSetOptions('collision ode')

manips = orRobotGetManipulators(robotid);

activeManip=3;

fprintf('Working with Manipulator #%d',activeManip);

activedofs = [manips{3}.armjoints,manips{4}.armjoints,manips{5}.armjoints]
orRobotSetActiveDOFs(robotid,activedofs);
%visualizeDOF(robotid,0:32);

objectid = orEnvCreateKinBody('footPlate','openHubo/footPlate.kinbody.xml');

%create the problem instance
probs.cbirrt = orEnvCreateProblem('CBiRRT','jaemiHubo');

%get the descriptions of the robot's manipulators
manips = orRobotGetManipulators(robotid);

%Set Arms to non-colliding pose
orRobotSetDOFValues(robotid,[0 pi/3 0 0 0 0 0],manips{1}.armjoints);
orRobotSetDOFValues(robotid,[0 -pi/3 0 0 0 0 0],manips{2}.armjoints);

%set initial configuration
initLeftLeg = [0 0 0 -.2 .4 -.2 0];
initRightLeg = [0 0 -.2 .4 -.2 0];
initAffine = [0 0 0 0 0 0];

totalDOF=orBodyGetDOF(robotid);

initDOFValues=[initLeftLeg,initRightLeg,initAffine];

orRobotSetDOFValues(robotid,initDOFValues,activedofs);
orEnvWait(.1);
pause(.2)
T=orBodyGetLinks(robotid);
T0_w2=MakeTransform(T(:,36));
Tw_e2=MakeTransform();
T0_w3=MakeTransform(T(:,7));
Tw_e3=MakeTransform();

for k=1:50
    %Prepare for a new iteration:
    orRobotSetDOFValues(robotid,initDOFValues,activedofs);

    %Find a collision-free goal position
    goalInCollision=1;
    while(goalInCollision==1)
        r=rand()*pi/8-pi/16;
        p=rand()*pi/8-pi/16;
        y=rand()*pi/8-pi/16;
        R_t=Rz(y)*Rx(r)*Ry(p)
        t=rand(3,1).*[.5;.5;.1] - [.2 .3 0]';

        T0_w=[R_t,t;0 0 0 1];
        Tw_e1=[eye(3),[0;0;.008];0 0 0 1];

        orBodySetTransform(objectid, [GetRot(T0_w) GetTrans(T0_w)]');
        pause(.05)
        goalInCollision = orEnvCheckCollision(robotid)
    end
    disp('Found Collision-Free goal')
    pause(.5)

    orRobotSetDOFValues(robotid,initDOFValues,activedofs);
    %Allow a large range of rotations to reach the goal, just to see if the planner can do this
    Bw = [-.002 .002 -.002 .002 0 0.002 -.01 .01 -.01 .01 -.01 .01 ];
    TSRstring1 = SerializeTSR(activeManip,'NULL',T0_w,Tw_e1,Bw);
    TSR1 = SerializeTSRChain(0,1,0,1,TSRstring1,'NULL',[]);

    Bw2 = zeros(1,12);
    leftTSR = SerializeTSR(2,'NULL',T0_w2,Tw_e2,Bw2);
    TSR2 = SerializeTSRChain(0,1,1,1,leftTSR,'NULL',[]);

    Bw3 = [-.01 .01 -.1 .1 -0.1 0 0 0 0 0 0 0];
    TSRstring3 = SerializeTSR(4,'NULL',T0_w3,Tw_e3,Bw3);
    TSR3 = SerializeTSRChain(0,1,1,1,TSRstring3,'NULL',[]);
    %call the cbirrt planner, it will generate a file with the trajectory called 'cmovetraj.txt'
    soln=orProblemSendCommand(['RunCBiRRT psample 0.20 timelimit 30 smoothingitrs 20' TSR1 TSR2 TSR3],probs.cbirrt)
    if strcmp(soln,'1')
        %execute the trajectories generated by the planner
        processTraj('cmovetraj.txt',.01)
        orProblemSendCommand(['traj new-cmovetraj.txt'],probs.cbirrt);
        orEnvWait(robotid);
        exportACESTraj('cmovetraj.txt',.01,10,'stairStepDemo.txt',jointPairs);
        break;
    end
end
