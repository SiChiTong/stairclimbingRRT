%Clear old variables and such
%TODO: clear specific variables and figures used in this script (i.e., a destroy function)
clear all;
close all;

%load the environment
orEnvLoadScene('openHubo/jaemiHubo.robot.xml',1);
objectid = orEnvCreateKinBody('sodacan','openHubo/testcylinder.kinbody.xml');
T0_object = MakeTransform(eye(3),[.26 0 -.15]');
orBodySetTransform(objectid, [GetRot(T0_object) GetTrans(T0_object)]');

robotid = orEnvGetBody('jaemiHubo');

%Define an obstacle to avoid
%objectid = orEnvCreateKinBody('boxobstacle','../ormodels/objects/household/bigbox.kinbody.xml');
%T0_Box1 = MakeTransform(eye(3),[0.591 -2.401 1.026]');
%orBodySetTransform(objectid, [GetRot(T0_Box1) GetTrans(T0_Box1)]');
%objectid = orEnvCreateKinBody('boxobstacle2','../ormodels/objects/household/bigbox.kinbody.xml');
%T0_Box2 = MakeTransform(eye(3),[-.5 -2.401 1.026]');
%orBodySetTransform(objectid, [GetRot(T0_Box2) GetTrans(T0_Box2)]');

%set printing and display options
orEnvSetOptions('debug 3')
orEnvSetOptions('collision ode')
disp('Initial setup done');
%create problem instances 
probs.cbirrt = orEnvCreateProblem('CBiRRT','jaemiHubo');

%get the descriptions of the robot's manipulators
manips = orRobotGetManipulators(robotid);

% Set arm dofs for left arm as active manipulator
activedofs = [manips{1}.armjoints];

% start the robot in a reasonable location and configuration
disp('set initial transform');
initdofvals = [-pi/8,pi/4,0,-pi/4,0,0,0];
orRobotSetActiveDOFs(robotid,activedofs);

%place the first TSR's reference frame at the object's frame relative to world frame

for k=1:10
    % 1) Choose a random position and orientation for the soda can
    tscale=[.2 .2 .1]';
    %Cetner of random distribution as position wrt torso
    tcenter=[.26 .05 -.15]';
    t_can=rand(3,1).*tscale-tscale/2+tcenter;

    T0_object = MakeTransform(eye(3),t_can);
    orRobotSetDOFValues(robotid,initdofvals,[manips{1}.armjoints]);
    orBodySetTransform(objectid, [GetRot(T0_object) GetTrans(T0_object)]');
    orEnvWait();
    pause(1)

    % 2) Define the ideal grap position in w coordinates (i.e. the frame of the soda can)
    palm_translation =[0 0.04 0];
    Tw_e1 = MakeTransform(eye(3),palm_translation');

    T0_w = T0_object;

    %3) Define the bounds of the workspace goal region. This 12x1 vector
    %defines the range that the ACTUAL end effector transformation can take,
    %with the ideal end effector transformation specified as Tw_e. This
    %specification is in w coordinates.
    %NOTE: The rotation range allowed (last 6 coordinates) are about the W axes.
    Bw = [-0 0  -0 0   -0.02 0.02   0 0   0 0   -pi pi];

    %Define the TSR's based on the chosen WGR
    TSRstring1 = SerializeTSR(0,'NULL',T0_w,Tw_e1,Bw);
    TSRChainString1 = SerializeTSRChain(0,1,0,1,TSRstring1,'NULL',[]);

    %now define the second TSR chain it is the same as the first TSR Chain
    %except Tw_e is different (the hand is rotated by 180 degrees about its x
    %axis)
    Tw_e2 = MakeTransform(rodrigues([pi 0 0]),palm_translation');

    TSRstring2 = SerializeTSR(0,'NULL',T0_w,Tw_e2,Bw);
    TSRChainString2 = SerializeTSRChain(0,1,0,1,TSRstring2,'NULL',[]);

    %call the cbirrt planner, it will generate a file with the trajectory
    %called 'cmovetraj.txt'
    orProblemSendCommand(['RunCBiRRT psample 0.05 '...
        TSRChainString1 ' '  TSRChainString2],probs.cbirrt);

    %execute the trajectories generated by the planner
    processTraj('cmovetraj.txt',.01);
    orProblemSendCommand(['traj cmovetraj.txt'],probs.cbirrt);
    orEnvWait(robotid);
    pause(1)
end

